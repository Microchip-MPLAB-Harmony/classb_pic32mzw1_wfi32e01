var SearchFiles = ["GUID-B046F97C-6BDC-45FC-BC1F-8C54B8F6F09A.html",
							"GUID-CCE57066-B6C1-4371-8E09-EF0F70ADC922.html",
							"GUID-AD62D00F-1E5E-4B0A-8F53-1866CD47D30B.html",
							"GUID-61E01A71-6A37-4EEA-8292-F1D1D6A9B680.html",
							"GUID-619641B0-DBDC-4B08-BBA8-6BCEEFD110A0.html",
							"GUID-8C976313-0E57-48A3-8EA6-4599439A0092.html",
							"GUID-E1D68AD2-7422-4A2A-A558-391FD77CD340.html",
							"GUID-8BA16DEC-E553-44E7-9EBC-78EAE1446F27.html",
							"GUID-4537661B-6C75-4B5F-AA07-3269CF6B3C6E.html",
							"GUID-3D73A66C-FC6C-4BCC-A0A1-21FF31F2A71E.html",
							"GUID-6CECDC39-7E68-46E6-B958-F48B3392CB1C.html",
							"GUID-9823EFF4-2B47-4077-BB8D-BF1C74FFCB66.html",
							"GUID-45405342-E12D-476A-9B86-77BD501E1766.html",
							"GUID-A079F8CC-E2A0-452E-9166-F285E1AEE2C9.html",
							"GUID-F61F612F-75CB-4600-AD6F-7CF7D75407D3.html",
							"GUID-F7768298-7179-49A1-8489-5D4BD3D37579.html",
							"GUID-51127D44-8908-469D-8943-1F7483224DAE.html",
							"GUID-27B8A7B2-0038-445F-AD77-A372C0554B45.html",
							"GUID-9D925FFD-EFF2-40B0-8B8E-855D5F7D071D.html",
							"GUID-602A1334-714B-4289-9EBA-FAE91ED4066E.html",
							"GUID-E5118550-D100-4A77-95AF-30797C1A9537.html",
							"GUID-AD30D375-BA6E-4C5B-A90D-4711D3F09F31.html",
							"GUID-23A88CA4-D27F-4DF9-8076-2AF71C7004AE.html",
							"GUID-8AAE4BDD-EFBF-48C3-8889-84955E137C8E.html",
							"GUID-452BC9BE-F5D8-4DE1-BE7B-1B147B5044A7.html",
							"GUID-74D6C5A5-5188-47CC-8F65-2FA26514AFBE.html",
							"GUID-8C5BC531-7BAE-4369-982F-1F18D6CD2528.html",
							"GUID-DA8C77CC-D696-4480-9DDF-10237F31C00A.html",
							"GUID-97A3FD8F-647D-4590-9878-1C1268CD4757.html",
							"GUID-97A3FD8F-647D-4590-9878-1C1268CD4757.html",
							"GUID-143383FB-0090-4FC4-9577-DED0B7EAB186.html",
							"GUID-9235F2F4-3CDF-46A4-B710-D290AA09B1D4.html",
							"GUID-7106413A-66EF-4F12-A8AE-69BA77F50E23.html",
							"GUID-F89756AD-AEC4-4FD9-A23F-0E1505980E96.html",
							"GUID-E330D7D0-F057-48C1-8F00-8271644ACA35.html",
							"GUID-17088B6E-BCED-4B42-AF08-72AB2FE31ED0.html",
							"GUID-26329DD5-2467-43AD-BAED-65C7CF94C7C2.html",
							"GUID-45E10218-E3FB-466E-A125-94AC6CD4D8B3.html",
							"GUID-048C12C1-6ED3-4155-AE80-CB6F20E59FCD.html",
							"GUID-350D1148-A2A0-4F9D-A166-BE25FEB2A842.html",
							"GUID-F6690318-A4BF-4962-A6CE-7524D60D1FF5.html",
							"GUID-77029010-B5F8-46CB-B99A-AD73D24F9115.html",
							"GUID-35E81007-8341-48AB-AD50-4AEE24DC3326.html",
							"GUID-5D425E8C-8325-4F9F-8557-59282A6B63B1.html",
							"GUID-2300B24F-0091-4818-BC0F-B79341A26941.html",
							"GUID-17237FED-3B75-4E81-B1B9-FFE1653B648B.html",
							"GUID-88043599-F30C-4941-A65B-5D6DEF191040.html",
							"GUID-4B422C6C-B783-4B28-91AF-04FFEB0CEE83.html",
							"GUID-11D799A9-929A-47E1-9459-CF7599F61310.html",
							"GUID-A60BF63D-D41D-4183-8A79-69B779C7AF3A.html",
							"GUID-AD965D66-F722-466F-871C-FD8CD73DAB08.html",
							"GUID-75A1E221-5BCA-4562-A22E-438504EFA9CA.html",
							"GUID-0E6BF7A6-377C-4384-8421-D81F30D77E09.html",
							"GUID-A1A352F6-517A-43CA-9680-72C02A8945E9.html",
							"GUID-9F52A374-7DDE-47D7-B87E-64096C98B5E7.html",
							"GUID-E59AD698-A8C2-4AE8-9279-1DC3A7DECDB5.html",
							"GUID-206721F4-2684-4736-A544-44D11B17DEA2.html",
							"GUID-28A74005-FBD0-483A-8CB5-4DFC36E9B81F.html"];

var SearchTitles = ["MPLAB® Harmony Class B Library for PIC32MZ W1 devices",
"CLASSB_CLOCK_DEFAULT_CLOCK_FREQ",
"CLASSB_CLOCK_ERROR_PERCENT",
"CLASSB_CLOCK_MAX_CLOCK_FREQ",
"CLASSB_CLOCK_MAX_SYSTICK_VAL",
"CLASSB_CLOCK_MAX_TEST_ACCURACY",
"CLASSB_CLOCK_MUL_FACTOR",
"CLASSB_CLOCK_TMR1_CLK_FREQ",
"CLASSB_CLOCK_TEST_TMR1_RATIO_NS",
"CLASSB_CLOCK_TEST_RATIO_NS_MS",
"CLASSB_COMPL_RESULT_ADDR",
"CLASSB_FLASH_CRC32_POLYNOMIAL",
"CLASSB_INTERRUPT_COUNT_VAR_ADDR",
"CLASSB_INTERRUPT_TEST_VAR_ADDR",
"CLASSB_INTR_MAX_INT_COUNT",
"CLASSB_INVALID_TEST_ID",
"CLASSB_ONGOING_TEST_VAR_ADDR",
"CLASSB_RESULT_ADDR",
"CLASSB_SRAM_ALL_32BITS_HIGH",
"CLASSB_SRAM_APP_AREA_START",
"CLASSB_SRAM_BUFF_START_ADDRESS",
"CLASSB_SRAM_FINAL_WORD_ADDRESS",
"CLASSB_SRAM_STARTUP_TEST_SIZE",
"CLASSB_SRAM_TEMP_STACK_ADDRESS",
"CLASSB_TEST_IN_PROG_VAR_ADDR",
"CLASSB_WDT_TEST_IN_PROG_VAR_ADDR",
"CLASSB_SST_RESULT_BF",
"CLASSB_RST_RESULT_BF",
"CLASSB_CPU_PC_TEST_VALUES",
"Interface Routines",
"CLASSB_INIT_STATUS",
"CLASSB_PORT_INDEX",
"CLASSB_PORT_PIN",
"CLASSB_PORT_PIN_STATE",
"CLASSB_SRAM_MARCH_ALGO",
"CLASSB_STARTUP_STATUS",
"CLASSB_TEST_ID",
"CLASSB_TEST_STATUS",
"CLASSB_TEST_STATE",
"CLASSB_TEST_TYPE",
"CLASSB_App_WDT_Recovery",
"CLASSB_CPU_RegistersTest",
"CLASSB_CPU_PCTest",
"CLASSB_ClearTestResults",
"CLASSB_ClockTest",
"CLASSB_GetTestResult",
"CLASSB_FlashCRCGenerate",
"CLASSB_FlashCRCTest",
"CLASSB_GlobalsInit",
"CLASSB_Init",
"CLASSB_SelfTest_FailSafe",
"CLASSB_SRAM_MarchTestInit",
"CLASSB_RST_IOTest",
"CLASSB_SRAM_TEST_BUFFER_SIZE",
"CLASSB_SST_InterruptTest",
"CLASSB_SST_WDT_Recovery",
"CLASSB_Startup_Tests",
"CLASSB_TestWDT"];

var SearchInfo = [" MPLAB® Harmony Class B Library for PIC32MZ W1 devices The Class B Library provides APIs to perform self-tests for the on-board systems of the microcontroller Features Tested by the Class B Library Following table shows the components tested by the Class B library Component Reference (Table H1 of IEC 60730-1) Fault/Error Acceptable Measures CPU Registers 1 1 Stuck-at Static memory test CPU Program Counter 1 3 Stuck-at Static memory test Interrupts 2 No interrupt / too frequent interrupt Functional test CPU Clock 3 Wrong frequency Frequency monitoring Flash 4 1 All single bit faults Modified checksum SRAM 4 2 DC fault Static memory test SRAM data path 5 1 Stuck-at Static memory test SRAM data path 5 2 Wrong address Static memory test Digital I/O 7 1 Abnormal operation Input comparison or output verification Class B Peripheral Library Usage This topic describes the basic architecture of the Class B library and provides information and examples on how to use it APIs defined by the Class B library can be used either by the start-up code or by the application code The application may use PLIBs drivers or middleware from the Harmony 3 software framework along with the Class B library code Abstraction Model The following picture shows positioning of Class B library in a Harmony 3 based application H3_ClassB_Architecture Start-up vs Run-time The Class B library contains many self-test routines those can be executed at startup and run-time If a self-test is executed at startup it is called as a Start-up Self-test (SST) and if it is executed at run-time then it is called a Run-time Self-test (RST) There are a few self-tests which can be used only as SST or as RST such self-tests have SST or RST in the API name eg: CLASSB_RST_IOTest()  CLASSB_SST_InterruptTest() If a self-test API does not have SST or RST in its name then it can be used at startup as well as runtime Start-up Self-test (SST) SSTs are used to test a component inside the microcontroller before it is initialized and used When the Class B library is added via MHC the selected SSTs are inserted into the _on_bootstrap() function which is called during start-up before main This means that none of the data initialization could have happened before running SSTs So the Class B library initializes necessary variables before using them It is not mandatory to test all the components during startup The SRAM can be tested partially if a faster startup is needed by the application In this case modify the corresponding configuration macro ( CLASSB_SRAM_STARTUP_TEST_SIZE ) present in classb h file to change the size of the tested area Run-time Self-test (RST) RSTs can be used by the application during run-time to check safe operation of different components in the microcontroller These tests are non-destructive In the case of run-time tests the application shall decide which test to execute when Components in the Library The Class B library contains self-test routines for different components inside the CPU ClassB_SYS_Elements Critical and Non-critical Components Based on the impact of failure different components inside this Class B library are categorized as critical or non-critical If the self-test for CPU registers PC or Flash detects a failure the code execution is stopped and it remains in an infinite loop This is to prevent unsafe code execution In the case of non-critical components a failsafe function ( CLASSB_SelfTest_FailSafe ) is called when a failure is detected This function contains a software break point and an infinite loop Further code shall be added into this function as per the application need The failsafe function must not return to the Class B library since it is called due to a self-test failure Avoid use of features which depend on the failed component For example if self-test for clock is failed it is not advisable to use UART for error reporting as BAUD rate may not be accurate In the case of SRAM failure avoid the use of function calls or use of variables in SRAM A simple error reporting mechanism in this case of SRAM failure can be toggling of an IO pin Critical Components CPU registers including the Program Counter Internal Flash program memory Generic Flow of Critical Tests Generic_flow_Critical_test Non-critical Components CPU clock IO pins Internal SRAM Interrupts Generic Flow of Non-Critical Tests Generic_flow_Non_critial_tests Self-tests for Components in the Library CPU Registers The MIPS32® M-Class Microprocessor Core is the CPU on the PIC32MZW1 devices The Class B library checks the processor core registers for stuck-at faults The stuck-at condition causes register bit to remain at logic 0 or logic 1 Code execution should be stopped if this error condition is detected in any of the CPU registers This self-test follows the register save/restore convention specified by AAPCS It can be used at startup as well as run-time The Program Counter (PC) self-test is designed as a separate test since this register cannot be checked with usual test data patterns Flow chart of the self-test for CPU registers DD_Test_CPU Program Counter (PC) The self-test for PC checks whether a stuck-at condition is present in the PC register The stuck-at condition causes register bit to remain at logic 0 or logic 1 Code execution should be stopped if this error condition is detected The self-test for PC calls multiple functions in predefined order and verifies that each function is executed and returns the expected value If the return values of all test functions are correct the Program Counter is assumed to be working fine This self-test can be used at startup as well as run-time Flow chart of the self-test for Program Counter (PC) DD_PC_TEST Flash The internal flash memory of the device needs to be checked for proper functionality The self-test for internal flash performs CRC check on the internal flash memory of the device The address range is configurable for this self-test It runs CRC-32 algorithm with reversed representation of the polynomial 0x04C11DB7 and compares the generated checksum with the expected checksum It uses table-based approach where the table is generated during the execution This self-test uses a CRC-32 generation function This function is used inside the Class B library to generate CRC-32 of the internal Flash memory but it can be used on any contiguous memory area The flash self-test can be used at startup as well as run-time If this self-test is used during start up it must be ensured that the CRC of the application area is precalculated and stored at a specific memory address which is passed as an argument for the Flash self-test If this self-test detects a failure it remains in an infinite loop Flow chart of the self-test for internal flash program memory DD_Flash SRAM Self-test for the SRAM element looks for stuck-at faults DC faults and addressing faults with the help of RAM March algorithms One of the input arguments to this self-test selects the algorithm This self-test copies the data from the tested area of the SRAM into the reserved area in the SRAM and restore the data after the test Refer to section Configuring the Library for the details on reserving the SRAM The stack pointer is moved to the reserved area in the SRAM before running this self-test The SRAM self-test can be used at startup as well as run-time It provides three standard tests to detect error conditions March C March C minus March B Fault Coverage for March Algorithms Name Fault Coverage March C Addressing faults Stuck-at faults Transition faults all coupling faults March C- Unlinked addressing faults Stuck-at faults Transition faults all coupling faults March B Addressing faults Stuck-at faults Transition faults Linked idempotent coupling faults Linked inversion coupling faults Flow chart of the self-test for SRAM DD_Test_Init_SRAM Flow chart of the internal routine for SRAM self-test DD_Test_SRAM Clock The self-test for CPU clock checks whether the CPU clock frequency is within the permissible range It uses TMR1 and SysTick to measure the CPU clock frequency The TMR1 is clocked at 32768 Hz from the 32 kHz External Crystal Oscillator and CPU clock can be from any other high frequency oscillator If the CPU clock frequency is within specified error limit it returns PASS The test duration is defined by one of the input arguments The clock self-test can be used at startup as well as run-time Note This self-test uses the TMR1 peripheral Thus if it is used during run-time the TMR1 shall not be used by the application for continuous modes If the TMR1 is used for some other purpose it must be reconfigured after running the clock self-test Keep the clock test duration lesser than the WDT timeout period to avoid the WDT resetting the device Flow chart of the self-test for CPU clock frequency DD_Clock Interrupt The self-test for this element checks the interrupts functionality of the microcontroller It configures the EVIC the Timer 1 (TMR1) and the Timer 2 (TMR2) peripherals to test the interrupt handling mechanism It verifies that at least one interrupt is generated and handled properly This self-test also checks whether the number of interrupts generated are too many within a given time period TMR1 is configured for polling (Without ISR) It reports a PASS if the total number of interrupts generated by the TMR2 is greater than one and less than the specified upper limit The clock used for TMR1 and TMR2 is from the Internal peripheral clock The interrupt self-test can be used only at startup Note TThis startup self-test utilizes the interrupts generated by TMR2 and TMR1 with polling method For run-time testing of interrupts a separate self-test need to be developed Flow chart of the self-test for interrupts DD_SST_Interrupt IO pin The self-test for IO pins verifies that any output pin is able to keep the configured logic state on the pin and any input pin is able to read the logic state present on the pin As the exact use of an IO pin is decide by the application it is the responsibility of the application to configure the IO pin direction and drive the pin to the expected state before calling this self-test When testing an input pin ensure that the IO pin is externally kept at a defined logic state The IO pin self-test can be used only at run-time Flow chart of the self-test for IO pins DD_RST_IO Class B Peripheral Library - Timing of self-tests Peripherals other than Flash and SRAM Name Time (in miroseconds) CLASSB_CPU_RegistersTest 82 CLASSB_CPU_PCTest 3 CLASSB_RST_IOTest 2 CLASSB_ClockTest 124347 CLASSB_SST_InterruptTest 107015 Flash and SRAM Name Time (in milliseconds) Tested size CLASSB_FlashCRCTest 6 122 KB CLASSB_SRAM_MarchTestInit 332 32 KB Note Timing is measured using onchip peripherals (Coretimer and TIMER5) at optimization level -O1 with CPU running at 200MHz from the internal 200MHz oscillator Before using these self-tests in an application it is recommended to check self-test timings with the required configuration (CPU clock compiler optimization memory size) Timing measured for CLASSB_SRAM_MarchTestInit using the ‘March C’ algorithm Following IDE and toolchain are used for timing measurements MPLAB X v6 00 XC32 Compiler v3 01 Configuring the Library (MPLAB X) This section provides details necessary to integrate the Class B library with other software components Optimization Requirements The self-test routines provides by the Class B software has specific optimization requirements which are listed in the following table If the optimization level for the project is different from what is listed in this table file level optimization has to be applied as per this table File Optimization Level classb_cpu_pc_test c classb_sram_algorithm c -O0 All other files ( h c S) -O1 or -O2 or -O3 Applying File Level Optimization MPLAB X MPLABX_file_optimization Reserved SRAM area for the Class B library It is required to reserve 1kB of SRAM for exclusive use by the Class B library This reserved SRAM must not be accessed from outside the Class B library To check or update test results use the corresponding interface APIs When the Class B library is added into the project with the help of MHC the linker setting is modified by MHC as shown below -mreserve=data@0x00000000:0x000003ff xc32_ld_SRAM_Reserve Modified Startup Sequence When generating project with help of MPLAB Harmony 3 the startup code is present in a file named crt0 s This is a compiler provided file and can be found in local folder of pc xc32 v3 01 pic32mx lib after installation of xc32 compiler Initialization of the Class B library is done from the _on_bootstrap function which is to be executed inside before main() The function named CLASSB_Startup_Tests executes all startup self-tests inserted into classb c file by the MHC If none of the self-tests are failed this function returns CLASSB_STARTUP_TEST_PASSED If any of the startup self-tests are failed this function does not return becasue of the following reason In the case of critical failures (CPU registers or internal flash) the corresponding self-test remains in an infinite loop to avoid unsafe execution of code The self-tests for SRAM Clock and Interrupt are considered non-critical since it may be possible to execute a fail-safe function after detecting a failure In such case the CLASSB_SelfTest_FailSafe() function is called when a failure is detected Since the default implementation of CLASSB_SelfTest_FailSafe routine contains an infinite loop it won't return to the caller Note The library defines the _on_bootstrap function and handles some of the reset causes The application developer shall insert functions to handle the rest of the reset causes WDT Test and Timeout The Watchdog timer is used as a recovery mechanism in case of software failures The Class B library enables the WDT and checks whether a WDT reset is issued if the timer is not cleared In _on_bootstrap (in file classb c ) before performing startup self-tests the WDT timeout period is configured If any of these self-tests takes more time than the WDT timeout period it results in a WDT reset Thus properly configuring the WDT period is essential during startup as well as runtime WDT_STARTUP_A  WDT_STARTUP_B Configuring Startup Tests via MHC Clone the classb_pic32mzw1_wfi32e01 repo When an MPLAB Harmony 3 project is created the MHC lists all available components that can be added to the project The self-tests which need to run during startup can be configured via MHC The Configuration Options menu appears with a mouse click on the Class B Library component inside the Project Graph The configurations done via MHC does not configure the library instead it helps to modify the input arguments and to decide whether to run a specific test during startup MHC_project_graph Class B Library Interface Name Description Constants Summary CLASSB_CLOCK_DEFAULT_CLOCK_FREQ Default CPU clock speed CLASSB_CLOCK_ERROR_PERCENT Clock error percentage selected for startup test CLASSB_CLOCK_MAX_CLOCK_FREQ Maximum CPU clock speed CLASSB_CLOCK_MAX_SYSTICK_VAL Upper limit of SysTick counter CLASSB_CLOCK_MAX_TEST_ACCURACY Maximum detectable accuracy for clock self-test CLASSB_CLOCK_MUL_FACTOR Multiplication factor used in clock test CLASSB_CLOCK_TEST_TMR1_RATIO_NS Duration of TMR1 clock in nano seconds CLASSB_CLOCK_TEST_RATIO_NS_MS Ratio of milli second to nano second CLASSB_COMPL_RESULT_ADDR Address of one's complement test results CLASSB_FLASH_CRC32_POLYNOMIAL CRC-32 polynomial CLASSB_INTERRUPT_COUNT_VAR_ADDR Address of the variable which keeps interrupt count CLASSB_INTERRUPT_TEST_VAR_ADDR Address of the variable which keeps interrupt test internal status CLASSB_INTR_MAX_INT_COUNT Defines the upper limit for interrupt count CLASSB_INVALID_TEST_ID Invalid test ID CLASSB_ONGOING_TEST_VAR_ADDR Address at which the ID of ongoing test is stored CLASSB_RESULT_ADDR Address of test results CLASSB_SRAM_ALL_32BITS_HIGH Defines name for max 32-bit unsigned value CLASSB_SRAM_APP_AREA_START Defines the start address of the SRAM for the application CLASSB_SRAM_BUFF_START_ADDRESS SRAM test buffer start address CLASSB_SRAM_FINAL_WORD_ADDRESS Final word address in the SRAM CLASSB_SRAM_STARTUP_TEST_SIZE Size of the SRAM tested during startup CLASSB_SRAM_TEST_BUFFER_SIZE Defines the size of the buffer used for SRAM test CLASSB_SRAM_TEMP_STACK_ADDRESS Address of the temporary stack CLASSB_TEST_IN_PROG_VAR_ADDR Address of the variable which indicates that a Class B test is in progress CLASSB_WDT_TEST_IN_PROG_VAR_ADDR Address of the variable which indicates that a WDT test is in progress Data types Summary *CLASSB_SST_RESULT_BF Pointer to the structure for the Class B library startup self-test result This can be used to point to the result address 0xA0000000 It will help to see the result in text form via watch window *CLASSB_RST_RESULT_BF Pointer to the structure for the Class B library run-time self-test result This can be used to point to the result address 0xA0000004 It will help to see the result in text form via watch window CLASSB_CPU_PC_TEST_VALUES Data type for PC Test input and output values CLASSB_INIT_STATUS Identifies Class B initialization status CLASSB_PORT_INDEX PORT index definitions for Class B library I/O pin test CLASSB_PORT_PIN PIN definitions for Class B library I/O pin test CLASSB_PORT_PIN_STATE PORT pin state CLASSB_SRAM_MARCH_ALGO Selects the RAM March algorithm to run CLASSB_STARTUP_STATUS Identifies startup test status CLASSB_TEST_ID Identifies Class B library tests CLASSB_TEST_STATUS Identifies result from Class B library test CLASSB_TEST_STATE Identifies Class B library test state CLASSB_TEST_TYPE Identifies type of the Class B library test Interface Routines Summary CLASSB_App_WDT_Recovery This function is called if a WDT reset has happened during run-time CLASSB_CPU_RegistersTest This self-test checks the processor core registers CLASSB_CPU_PCTest This self-test checks the Program Counter register (PC) CLASSB_ClearTestResults Clears the results of SSTs or RSTs CLASSB_ClockTest This self-test checks whether the CPU clock frequency is within the permissible limit CLASSB_GetTestResult Returns the result of the specified self-test CLASSB_FlashCRCGenerate Generates CRC-32 checksum for a given memory area CLASSB_FlashCRCTest This self-test checks the internal Flash program memory to detect single bit faults CLASSB_GlobalsInit This function initializes the global variables for the classb library CLASSB_Init This function is executed on every device reset This shall be called right after the reset before any other initialization is performed CLASSB_SelfTest_FailSafe This function is called if any of the non-critical tests detects a failure CLASSB_SRAM_MarchTestInit This self-test checks the SRAM with the help of RAM March algorithm CLASSB_SST_InterruptTest This self-test checks basic functionality of the interrupt handling mechanism CLASSB_SST_WDT_Recovery This function is called if a WDT reset has happened during the execution of an SST CLASSB_Startup_Tests This function executes all startup self-tests inserted into classb c file CLASSB_RST_IOTest This self-test can be used to perform plausibility checks on IO pins CLASSB_TestWDT This function tests the WatchDog Timer (WDT) ",
							" CLASSB_CLOCK_DEFAULT_CLOCK_FREQ Summary Default CPU clock speed Description Defines the default CPU clock speed after a reset Remarks This value must not be modified # define CLASSB_CLOCK_DEFAULT_CLOCK_FREQ (200000000U) ",
							" CLASSB_CLOCK_ERROR_PERCENT Summary Clock error percentage selected for startup test Description Defines the acceptable error percentage of the CPU clock This value is configured via MHC and is used during startup self-test of the CPU clock Remarks This value must not be modified # define CLASSB_CLOCK_ERROR_PERCENT (5U) ",
							" CLASSB_CLOCK_MAX_CLOCK_FREQ Summary Maximum CPU clock speed Description Defines the maximum CPU clock speed for the microcontroller Remarks This value must not be modified # define CLASSB_CLOCK_MAX_CLOCK_FREQ (200000000U) ",
							" CLASSB_CLOCK_MAX_SYSTICK_VAL Summary Upper limit of SysTick counter Description Defines the upper limit of SysTick counter Remarks This value must not be modified # define CLASSB_CLOCK_MAX_SYSTICK_VAL (0xffffffffU) ",
							" CLASSB_CLOCK_MAX_TEST_ACCURACY Summary Maximum detectable accuracy for clock self-test Description Defines the maximum detectable accuracy for clock self-test Remarks This value must not be modified # define CLASSB_CLOCK_MAX_TEST_ACCURACY (5U) ",
							" CLASSB_CLOCK_MUL_FACTOR Summary Multiplication factor used in clock test Description Defines the multiplication factor used in clock test This is used to calculate the CPU clock error Used to avoid the use of floating point math Remarks This value must not be modified # define CLASSB_CLOCK_MUL_FACTOR (128U) ",
							" CLASSB_CLOCK_TMR1_CLK_FREQ Summary TMR1 clock frequency Description Defines the TMR1 clock frequency Remarks This value must not be modified # define CLASSB_CLOCK_RTC_CLK_FREQ (32768U) ",
							" CLASSB_CLOCK_TEST_TMR1_RATIO_NS Summary Duration of TMR1 clock in nano seconds Description Defines the duration of TMR1 clock in nano seconds This is used to calculate the duration of CPU clock test in terms of TMR1 cycles Remarks TMR1 is clocked from 32768 Hz Crystal One TMR1 cycle is 30517 nano sec This value must not be modified # define CLASSB_CLOCK_TEST_TMR1_RATIO_NS (30517U) ",
							" CLASSB_CLOCK_TEST_RATIO_NS_MS Summary Ratio of milli second to nano second Description Defines the ratio of milli second to nano second This is used to calculate the duration of CPU clock test in terms of TMR1 cycles Remarks Used to avoid the use of floating point math This value must not be modified # define CLASSB_CLOCK_TEST_RATIO_NS_MS (1000000U) ",
							" CLASSB_COMPL_RESULT_ADDR Summary Address of one's complement test results Description This constant defines the address in SRAM where the one's complement of the test results are stored Remarks This value must not be modified # define CLASSB_COMPL_RESULT_ADDR (0xa0000004U) ",
							" CLASSB_FLASH_CRC32_POLYNOMIAL Summary CRC-32 polynomial Description Defines the CRC-32 polynomial used for Flash self-test Remarks This value must not be modified # define CLASSB_FLASH_CRC32_POLYNOMIAL (0xedb88320U) ",
							" CLASSB_INTERRUPT_COUNT_VAR_ADDR Summary Address of the variable which keeps interrupt count Description Defines the address of the variable which keeps interrupt count Remarks This value must not be modified # define CLASSB_INTERRUPT_COUNT_VAR_ADDR (0xa000001cU) ",
							" CLASSB_INTERRUPT_TEST_VAR_ADDR Summary Address of the variable which keeps interrupt test internal status Description Defines the address of the variable which keeps interrupt test internal status Remarks This value must not be modified # define CLASSB_INTERRUPT_TEST_VAR_ADDR (0xa0000018U) ",
							" CLASSB_INTR_MAX_INT_COUNT Summary Defines the upper limit for interrupt count Description This constant defines the upper limit for interrupt count for the interrupt self-test Remarks This value must not be modified # define CLASSB_INTR_MAX_INT_COUNT (15U) ",
							" CLASSB_INVALID_TEST_ID Summary Invalid test ID Description Defines a constant to initialize the variable which holds the ID of the ongoing self-test Remarks This value must not be modified # define CLASSB_INVALID_TEST_ID (0xFFU) ",
							" CLASSB_ONGOING_TEST_VAR_ADDR Summary Address at which the ID of ongoing test is stored Description This constant defines the address in SRAM where the the ID of ongoing test is stored Remarks This value must not be modified # define CLASSB_ONGOING_TEST_VAR_ADDR (0xa0000008U) ",
							" CLASSB_RESULT_ADDR Summary Address of test results Description This constant defines the address in SRAM where the test results are stored Remarks This value must not be modified # define CLASSB_RESULT_ADDR (0xA0000000U) ",
							" CLASSB_SRAM_ALL_32BITS_HIGH Summary Defines name for max 32-bit unsigned value Description This constant defines a name for max 32-bit unsigned value Remarks This value must not be modified # define CLASSB_SRAM_ALL_32BITS_HIGH (0xFFFFFFFFU) ",
							" CLASSB_SRAM_APP_AREA_START Summary Defines the start address of the SRAM for the application Description This constant defines the start address of the SRAM for the application First 1kB of the SRAM is reserved for the Class B library Remarks This value must not be modified # define CLASSB_SRAM_APP_AREA_START (0xa0000400U) ",
							" CLASSB_SRAM_BUFF_START_ADDRESS Summary SRAM test buffer start address Description This constant defines the SRAM test buffer start address This is used by the self-test for the SRAM Remarks This value must not be modified # define CLASSB_SRAM_BUFF_START_ADDRESS (0x80000200U) ",
							" CLASSB_SRAM_FINAL_WORD_ADDRESS Summary Final word address in the SRAM Description This constant defines the final word address in the SRAM Remarks This value must not be modified Varies depending on the device # define CLASSB_SRAM_FINAL_WORD_ADDRESS (0xa003fffcU) ",
							" CLASSB_SRAM_STARTUP_TEST_SIZE Summary Size of the SRAM tested during startup Description Defines the size of the SRAM tested during startup Modify this macro to change the area of the tested SRAM area The test size must be a multiple of four Remarks This value can be modified # define CLASSB_SRAM_STARTUP_TEST_SIZE (2048U) ",
							" CLASSB_SRAM_TEMP_STACK_ADDRESS Summary Address of the temporary stack Description This constant defines the address of the temporary stack used during SRAM self-test Remarks This value must not be modified # define CLASSB_SRAM_TEMP_STACK_ADDRESS (0x80000100U) ",
							" CLASSB_TEST_IN_PROG_VAR_ADDR Summary Address of the variable which indicates that a Class B test is in progress Description Defines the address of the variable which indicates that a Class B test is in progress Remarks This value must not be modified # define CLASSB_TEST_IN_PROG_VAR_ADDR (0xa000000CU) ",
							" CLASSB_WDT_TEST_IN_PROG_VAR_ADDR Summary Address of the variable which indicates that a WDT test is in progress Description Defines the address of the variable which indicates that a WDT test is in progress Remarks This value must not be modified # define CLASSB_WDT_TEST_IN_PROG_VAR_ADDR (0xa0000010U) ",
							" CLASSB_SST_RESULT_BF Summary Pointer to the structure for the Class B library startup self-test result Description For bit-field representation of Class B library test results Remarks None typedef  struct  { CLASSB_TEST_STATUS CPU_STATUS : 2 ; CLASSB_TEST_STATUS PC_STATUS : 2 ; CLASSB_TEST_STATUS RAM_STATUS : 2 ; CLASSB_TEST_STATUS FLASH_STATUS : 2 ; CLASSB_TEST_STATUS CLOCK_STATUS : 2 ; CLASSB_TEST_STATUS INTERRUPT_STATUS : 2 ;  }  * CLASSB_SST_RESULT_BF ; ",
							" CLASSB_RST_RESULT_BF Summary Pointer to the structure for the Class B library run-time self-test result Description For bit-field representation of Class B library test results Remarks None typedef  struct  { CLASSB_TEST_STATUS CPU_STATUS : 2 ; CLASSB_TEST_STATUS PC_STATUS : 2 ; CLASSB_TEST_STATUS RAM_STATUS : 2 ; CLASSB_TEST_STATUS FLASH_STATUS : 2 ; CLASSB_TEST_STATUS CLOCK_STATUS : 2 ; CLASSB_TEST_STATUS UNUSED_STATUS : 2 ; CLASSB_TEST_STATUS IO_STATUS : 2 ;  }  * CLASSB_RST_RESULT_BF ; ",
							" CLASSB_CPU_PC_TEST_VALUES Summary Data type for PC Test input and output values Description The PC tests performs logical left-shift of the input value and returns it Values from this enum can be used as arguments Remarks None typedef  enum  classb_pc_test_val  { CLASSB_CPU_PC_TEST_ROUTINE_A_INPUT =  1U  CLASSB_CPU_PC_ROUTINE_A_RET_VAL =  2U  CLASSB_CPU_PC_ROUTINE_B_RET_VAL =  4U  CLASSB_CPU_PC_ROUTINE_C_RET_VAL =  8U  CLASSB_CPU_PC_TEST_INIT_VAL =  0U  } CLASSB_CPU_PC_TEST_VALUES ; ",
							" Interface Routines ",
							" CLASSB_INIT_STATUS Summary Identifies Class B initialization status Description This is return type for the function which initializes the Class B library during startup This indicates whether the SSTs are executed or not Remarks None typedef  enum  { CLASSB_SST_DONE =  1  CLASSB_SST_NOT_DONE =  2  } CLASSB_INIT_STATUS ; ",
							" CLASSB_PORT_INDEX Summary PORT index definitions for Class B library I/O pin test Description This can be used in the I/O pin test Remarks None typedef  enum  { PORTA =  0  PORTB =  1  PORTC =  2   } CLASSB_PORT_INDEX ; ",
							" CLASSB_PORT_PIN Summary PIN definitions for Class B library I/O pin test Description This can be used in the I/O pin test Remarks None typedef  enum  { PIN0 =  0  PIN1 =  1  PIN2 =  2  PIN3 =  3  PIN4 =  4  PIN5 =  5  PIN6 =  6  PIN7 =  7  PIN8 =  8  PIN9 =  9  PIN10 =  10  PIN11 =  11  PIN12 =  12  PIN13 =  13  PIN14 =  14  PIN15 =  15  PIN16 =  16  PIN17 =  17  PIN18 =  18  PIN19 =  19  PIN20 =  20  PIN21 =  21  PIN22 =  22  PIN23 =  23  PIN24 =  24  PIN25 =  25  PIN26 =  26  PIN27 =  27  PIN28 =  28  PIN29 =  29  PIN30 =  30  PIN31 =  31  } CLASSB_PORT_PIN ; ",
							" CLASSB_PORT_PIN_STATE Summary PORT pin state Description This can be used in the I/O pin test Remarks None typedef  enum  { PORT_PIN_LOW =  0  PORT_PIN_HIGH =  1  PORT_PIN_INVALID =  2  } CLASSB_PORT_PIN_STATE ; ",
							" CLASSB_SRAM_MARCH_ALGO Summary Selects the RAM March algorithm to run Description Selects the RAM March algorithm to be used for the SRAM self-test Remarks None typedef  enum  { CLASSB_SRAM_MARCH_C =  0  CLASSB_SRAM_MARCH_C_MINUS =  1  CLASSB_SRAM_MARCH_B =  2  } CLASSB_SRAM_MARCH_ALGO ; ",
							" CLASSB_STARTUP_STATUS Summary Identifies startup test status Description This is return type for the function which calls all self-tests during startup Remarks None typedef  enum  { CLASSB_STARTUP_TEST_PASSED =  1  CLASSB_STARTUP_TEST_FAILED =  2  } CLASSB_STARTUP_STATUS ; ",
							" CLASSB_TEST_ID Summary Identifies Class B library tests Description This enumeration can be used to read the self-test status and update it Test ID corresponds to the bit position at which the 2-bit test result is stored Remarks None typedef  enum  { CLASSB_TEST_CPU =  0  CLASSB_TEST_PC =  2  CLASSB_TEST_RAM =  4  CLASSB_TEST_FLASH =  6  CLASSB_TEST_CLOCK =  8  CLASSB_TEST_INTERRUPT =  10  CLASSB_TEST_IO =  12  } CLASSB_TEST_ID ; ",
							" CLASSB_TEST_STATUS Summary Identifies result from Class B library test Description This is return type for self-tests Remarks None typedef  enum  { CLASSB_TEST_NOT_EXECUTED =  0  CLASSB_TEST_PASSED =  1  CLASSB_TEST_FAILED =  2  CLASSB_TEST_INPROGRESS =  3  } CLASSB_TEST_STATUS ; ",
							" CLASSB_TEST_STATE Summary Identifies Class B library test state Description This data type is used to update flags which indicates whether a test has started or not Remarks None typedef  enum  { CLASSB_TEST_NOT_STARTED =  0  CLASSB_TEST_STARTED =  1  } CLASSB_TEST_STATE ; ",
							" CLASSB_TEST_TYPE Summary Identifies type of the Class B library test Description There are two categories of test They are startup tests (SSTs) and run-time tests (RSTs) Test results for SSTs and RSTs are stored at separate locations in the SRAM Remarks None typedef  enum  { CLASSB_TEST_TYPE_SST =  0  CLASSB_TEST_TYPE_RST =  1  } CLASSB_TEST_TYPE ; ",
							" CLASSB_App_WDT_Recovery Function static  void  CLASSB_App_WDT_Recovery ( void ) ; Summary This function is called if a WDT reset is caused during run-time Description This function is used inside the CLASSB_Init() function When the device comes back from a WDT reset if a WDT test by the Class B library has not been in progress it is assumed that the WDT reset has happened since the application failed to clear the WDT during regular intervals In this case the CLASSB_App_WDT_Recovery() function is called from CLASSB_Init() Precondition None Parameters None Returns None Example if  ( ( RCON   ( _RCON_CMR_MASK | _RCON_EXTR_MASK | _RCON_SWR_MASK | _RCON_DMTO_MASK | _RCON_WDTO_MASK | _RCON_BOR_MASK | _RCON_POR_MASK | _RCON_VBPOR_MASK | _RCON_VBAT_MASK | _RCON_PORIO_MASK | _RCON_PORCORE_MASK )  == RSTC_RCAUSE_WDT_Msk )  {  if  (  ( * wdt_test_in_progress == CLASSB_TEST_STARTED ) )  {  CLASSB_SST_WDT_Recovery ( ) ;  }  } Remarks This function is for the internal use of the Class B library ",
							" CLASSB_CPU_RegistersTest Function CLASSB_TEST_STATUS CLASSB_CPU_RegistersTest ( bool running_context ) ; Summary This self-test checks the processor core registers of the CPU to detect stuck-at faults Description This self-test writes test patterns into the processor core registers and special function registers and read them back to detect stuck-at faults Special function register bits which are reserved or should not be modified during the test are not written Precondition None Parameters running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the CPU registers classb_test_status =  CLASSB_CPU_RegistersTest ( true ) ; Remarks This self-test can be used during startup as well as run-time If a failure is detected this self-test remains in an infinite loop to avoid unsafe code execution ",
							" CLASSB_CPU_PCTest Function CLASSB_TEST_STATUS CLASSB_CPU_PCTest ( bool running_context ) ; Summary This self-test checks the Program Counter register (PC) of the CPU to detect stuck-at faults Description This self-test calls multiple functions in predefined order and verifies that each function is executed and returns the expected value If the return values of all test functions are correct the Program Counter is assumed to be working fine Precondition None Parameters running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the PC classb_test_status =  CLASSB_CPU_PCTest ( true ) ; Remarks This self-test can be used during startup as well as run-time If a failure is detected this self-test remains in an infinite loop to avoid unsafe code execution ",
							" CLASSB_ClearTestResults Function void  CLASSB_ClearTestResults ( CLASSB_TEST_TYPE test_type ) ; Summary Clears the results of SSTs or RSTs Description This function clears all the test results of a given type of test Precondition None Parameters test_type - Can be CLASSB_TEST_TYPE_SST or CLASSB_TEST_TYPE_RST Returns None Example CLASSB_ClearTestResults ( CLASSB_TEST_TYPE_SST ) ;  CLASSB_ClearTestResults ( CLASSB_TEST_TYPE_RST ) ; Remarks This function is called from CLASSB_Init() ",
							" CLASSB_ClockTest Function CLASSB_TEST_STATUS CLASSB_ClockTest ( uint32_t cpu_clock_freq  uint8_t error_limit  uint16_t clock_test_tmr1_cycles  bool running_context ) ; Summary This self-test checks whether the CPU clock frequency is within the permissible limit Description This self-test uses TMR1 and SysTick to measure the CPU clock frequency The TMR1 is clocked at 32768 Hz from the external crystal and CPU clock can be from any other high frequency oscillator If the CPU clock frequency is within specified error limit it returns PASS The test duration is defined by the value of tmr1_cycles The TMR1 is configured to take clock from an external 32 768 kHz accurate crystal Precondition None Parameters cpu_clock_freq - Expected CPU clock frequency error_limit - Permissible error limit (eg; 5 means +-5 percent) clock_test_tmr1_cycles - The test duration in terms of TMR1 cycles running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the CPU clock classb_test_status =  CLASSB_ClockTest ( 120000000   5   500  true ) ; Remarks This self-test can be used during startup as well as run-time This self-test shall be used only if there is an external 32 768 kHz accurate crystal connected to the XOSC32K of the microcontroller ",
							" CLASSB_GetTestResult Function CLASSB_TEST_STATUS CLASSB_GetTestResult ( CLASSB_TEST_TYPE test_type  CLASSB_TEST_ID test_id ) ; Summary Returns the result of the specified self-test Description This function reads the test results from the reserved SRAM and extracts the result of the self-test specified by the input arguments Precondition None Parameters test_type - Can be CLASSB_TEST_TYPE_SST or CLASSB_TEST_TYPE_RST test_id - Identifier for a Class B library test Returns None Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ; classb_test_status =  CLASSB_GetTestResult ( CLASSB_TEST_TYPE_SST  CLASSB_TEST_CPU ) ; Remarks None ",
							" CLASSB_FlashCRCGenerate Function uint32_t CLASSB_FlashCRCGenerate ( uint32_t start_addr  uint32_t test_size ) ; Summary Generates CRC-32 checksum for a given memory area Description This function runs CRC-32 algorithm with the polynomial 0xEDB88320 and returns the generated checksum It uses table based approach where the table is generated during the execution It uses 0xffffffff as the initial value Precondition None Parameters start_addr - Starting address of the memory block test_size - Size of the memory block Returns CLASSB_TEST_STATUS - Status of the test Example uint32_t crc_val =  0 ;  // Generate CRC-32 for the internal Flash crc_val =  CLASSB_FlashCRCGenerate ( 0   0xFE000 ) ; Remarks This function is used inside the Class B library to generate CRC-32 of the internal Flash memory but it can be used on any contiguous memory area ",
							" CLASSB_FlashCRCTest Function CLASSB_TEST_STATUS CLASSB_FlashCRCTest ( uint32_t start_addr  uint32_t test_size  uint32_t crc_val  bool running_context ) ; Summary This self-test checks the internal Flash program memory to detect single bit faults Description This self-test generates CRC-32 checksum for the given memory area and compares it with the expected checksum Precondition None Parameters start_addr - Starting address of the memory block test_size - Size of the memory block crc_val - Expected CRC-32 checksum running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the internal Flash classb_test_status =  CLASSB_FlashCRCTest ( 0   0xFE000   * ( uint32_t * ) FLASH_CRC32_ADDR  true ) ; Remarks This self-test can be used during startup as well as run-time If a failure is detected this self-test remains in an infinite loop to avoid unsafe code execution ",
							" CLASSB_GlobalsInit Function static  void  CLASSB_GlobalsInit ( void ) ; Summary This function initializes the global variables for the classb library Description The parameters used by the Class B library are access with the help of pointer variables These variables are initialized by this function Precondition None Parameters None Returns None Example CLASSB_GlobalsInit ( ) ; Remarks None ",
							" CLASSB_Init Function static CLASSB_INIT_STATUS CLASSB_Init ( void ) ; Summary This function is executed on every device reset This shall be called right after the reset before any other initialization is performed Description This function performs the following a It initializes the global variables used by the Class B library b Checks the reset cause and decides next course of action c If the reset is not caused by the Class B library it tests the reserved SRAM area clears all self-test results and performs a WDT test Precondition None Parameters None Returns CLASSB_SST_DONE if all SSTs are successfully executed CLASSB_SST_NOT_DONE if SSTs are yet to be executed Example CLASSB_INIT_STATUS init_status =  CLASSB_Init ( ) ; Remarks None ",
							" CLASSB_SelfTest_FailSafe Function void  CLASSB_SelfTest_FailSafe ( CLASSB_TEST_ID test_id ) ; Summary This function is called if any of the non-critical tests are failed Description The self-tests for SRAM Clock and Interrupt are considered non-critical since it may be possible to execute a fail-safe function after detecting a failure if the fail-safe routine does not use the failed element on the microcontroller Default implementation of this function is available in classb c file The function contains an infinite loop Further code shall be added as per the application need Precondition None Parameters test_id - Identification number of the failed test Returns None Example if  ( classb_sram_status == CLASSB_TEST_FAILED )  {  CLASSB_SelfTest_FailSafe ( CLASSB_TEST_RAM ) ;  } Remarks This function must not return to the Class B library since it is called due to a self-test failure Avoid using features which depend on the failed component For example if self-test for clock is failed it is not advisable to use UART for error reporting since BAUD rate may not be accurate In the case of SRAM failure avoid the use of function calls or variables in SRAM The error reporting mechanism in this case can be an IO pin ",
							" CLASSB_SRAM_MarchTestInit Function CLASSB_TEST_STATUS CLASSB_SRAM_MarchTestInit ( uint32_t * start_addr  uint32_t test_size  CLASSB_SRAM_MARCH_ALGO march_algo  bool running_context ) ; Summary This self-test checks the SRAM with the help of RAM March algorithm Description This self-test run the selected RAM March algorithm on the SRAM to detect stuck-at fault DC fault and addressing fault Precondition None Parameters start_addr - Starting address of the memory block test_size - Size of the memory block march_algo - The selected RAM March algorithm It can be March C March C minus or March B running_context - False for startup test True for run-time test Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform run-time test of the internal SRAM classb_test_status =  CLASSB_SRAM_MarchTestInit ( ( uint32_t * ) CLASSB_SRAM_APP_AREA_START   1024  CLASSB_SRAM_MARCH_C  true ) ; Remarks This self-test can be used during startup as well as run-time Initial 1kB of the SRAM must be reserved for the Class B library ",
							" CLASSB_RST_IOTest Function CLASSB_TEST_STATUS CLASSB_RST_IOTest ( CLASSB_PORT_INDEX port  CLASSB_PORT_PIN pin  CLASSB_PORT_PIN_STATE state ) ; Summary This self-test can be used to perform plausibility checks on IO pins Description This self-test checks whether a given IO pin is at the expected logic state As the exact use of an IO pin is decide by the application it is the responsibility of the caller to configure the IO pin direction and drive the pin to the expected state before calling this self-test Precondition None Parameters port - Index of the IO PORT Defined by enum CLASSB_PORT_INDEX pin - Index of the pin on the given PORT Defined by enum CLASSB_PORT_PIN state - Expected logic state of the IO pin It can be PORT_PIN_LOW or PORT_PIN_HIGH Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform test of an IO pin at run-time classb_test_status =  CLASSB_RST_IOTest ( PORTB  PIN31  PORT_PIN_HIGH ) ; Remarks This self-test can be used only during run-time ",
							" CLASSB_SRAM_TEST_BUFFER_SIZE Summary Defines the size of the buffer used for SRAM test Description This constant defines the size of the buffer used for SRAM test Remarks This value must not be modified # define CLASSB_SRAM_TEST_BUFFER_SIZE (512U) ",
							" CLASSB_SST_InterruptTest Function CLASSB_TEST_STATUS CLASSB_SST_InterruptTest ( void ) ; Summary This self-test checks basic functionality of the interrupt handling mechanism Description This self-test configures the EVIC the TMR1 and the TMR2 peripheral to test the interrupt handling mechanism of the microcontroller It verifies that at least one interrupt is generated and handled properly This self-test also checks whether the number of interrupts generated are too many within a given time period It reports a PASS if the total number of interrupts generated by the TMR2 is less than the specified upper limit and greater than one Precondition None Parameters None Returns CLASSB_TEST_STATUS - Status of the test Example CLASSB_TEST_STATUS classb_test_status = CLASSB_TEST_NOT_EXECUTED ;  // Perform test of the Interrupt mechanism at start-up classb_test_status =  CLASSB_SST_InterruptTest ( ) ; Remarks This self-test can be used only during startup ",
							" CLASSB_SST_WDT_Recovery Function static  void  CLASSB_SST_WDT_Recovery ( void ) ; Summary This function is called if a WDT reset is caused while a startup self-test is running Description This function is used inside the CLASSB_Init() function When the device comes back from a WDT reset if there has been a startup self-test running it is assumed that the WDT reset has happened because a Class B self-test has taken more time that the WDT timeout period In this case the CLASSB_SST_WDT_Recovery() function is called from CLASSB_Init() Precondition None Parameters None Returns None Example if  ( ( RCON   ( _RCON_CMR_MASK | _RCON_EXTR_MASK | _RCON_SWR_MASK | _RCON_DMTO_MASK | _RCON_WDTO_MASK | _RCON_BOR_MASK | _RCON_POR_MASK | _RCON_VBPOR_MASK | _RCON_VBAT_MASK | _RCON_PORIO_MASK | _RCON_PORCORE_MASK ) )  == RSTC_RCAUSE_WDT_Msk )  {  if  ( * classb_test_in_progress == CLASSB_TEST_STARTED )  {  CLASSB_SST_WDT_Recovery ( ) ;  }  } Remarks This function is for the internal use of the Class B library ",
							" CLASSB_Startup_Tests Function static CLASSB_STARTUP_STATUS CLASSB_Startup_Tests ( void ) ; Summary This function executes all startup self-tests inserted into classb c file by the MHC Description This function is called from the '_on_bootstrap' function which is executed after a reset suring startup before main() If none of the self-tests are failed this function returns 'CLASSB_STARTUP_TEST_PASSED' If any of the startup self-tests are failed this function will not return The self-tests for SRAM Clock and Interrupt are considered non-critical since it may be possible to execute a fail-safe function after detecting a failure In such case the CLASSB_SelfTest_FailSafe() function is called when a failure is detected In the case of critical failures (CPU registers or internal flash) the corresponding self-test remains in an infinite loop to avoid unsafe execution of code Precondition None Parameters None Returns Pass or Fail Example CLASSB_STARTUP_STATUS startup_tests_status = CLASSB_STARTUP_TEST_FAILED ; startup_tests_status =  CLASSB_Startup_Tests ( ) ; Remarks This function does not return if any of the self-tests detects a failure ",
							" CLASSB_TestWDT Function static  void  CLASSB_TestWDT ( void ) ; Summary This function tests the WatchDog Timer (WDT) Description This function is called from CLASSB_Init() It tests whether the WDT can reset the device After the WDT resets the device the Class B library clears the test flag and proceeds to the rest of the initialization routines Since the test flag is kept in reserved SRAM area it is not touched by the general startup code Precondition None Parameters None Returns None Example CLASSB_TestWDT ( void ) ; Remarks Calling this function results in device reset by the WDT "];

